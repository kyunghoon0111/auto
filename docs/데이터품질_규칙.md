# DQ 규칙집

> SCM 운영 분석 DB의 데이터 품질 검사, 심각도 수준, 파이프라인 동작.

---

## 심각도 수준

| 수준 | 코드 | 파이프라인 동작 | 설명 |
|---|---|---|---|
| `CRITICAL` | `C` | **실패** -- 파일 거부, 0행 적재 | 다운스트림 테이블을 손상시킬 수 있는 데이터 무결성 위반 |
| `HIGH` | `H` | **실패** -- 파일 거부, 0행 적재 | 부정확한 분석을 유발하는 비즈니스 규칙 위반 |
| `MEDIUM` | `M` | **경고** -- 파일 적재, 이슈 기록 | 데이터 품질 우려; 결과가 저하될 수 있음 |
| `LOW` | `L` | **정보** -- 파일 적재, 이슈 기록 | 외관상 또는 정보성; 분석에 영향 없음 |

**규칙**: `CRITICAL`과 `HIGH` 모두 하드 **실패**를 유발합니다. 파일은 CORE에 적재되지 않으며, 이슈가 `ops.ops_issue_log`에 기록됩니다. 배치 내 다음 파일로 처리가 계속됩니다.

---

## DQ 검사 항목

### 1. `required_columns` (필수 컬럼)

| 속성 | 내용 |
|---|---|
| **심각도** | `CRITICAL` |
| **적용 대상** | 모든 테이블 |
| **규칙** | `schema.yaml`의 `required_columns`에 나열된 모든 컬럼이 별칭 매핑 후 수집 파일에 존재해야 함. |
| **트리거** | 필수 컬럼이 파일 헤더에 누락. |
| **조치** | 파일 거부. 적재 행 없음. |
| **예시** | `fact_order`는 `order_id`, `order_line_id`, `order_date`, `item_id`, `ordered_qty`를 필수로 함. 별칭 확인 후에도 `order_id`가 없으면 파일 거부. |

### 2. `null_business_keys` (비즈니스 키 NULL)

| 속성 | 내용 |
|---|---|
| **심각도** | `CRITICAL` |
| **적용 대상** | 복합 비즈니스 키가 있는 모든 테이블 |
| **규칙** | 테이블의 기본/비즈니스 키를 구성하는 어떤 컬럼에도 `NULL` 값이 허용되지 않음. 선택적 구성요소에는 센티넬 `'__NONE__'`을 사용해야 함. |
| **트리거** | 하나 이상의 행에서 비즈니스 키 컬럼에 `NULL` 존재. |
| **조치** | 파일 거부. 이슈 로그에 위반 행 수와 샘플 값 기록. |

테이블별 검사 비즈니스 키:

| 테이블 | 비즈니스 키 컬럼 |
|---|---|
| `fact_order` | `order_id`, `order_line_id` |
| `fact_shipment` | `shipment_id`, `shipment_line_id` |
| `fact_return` | `return_id`, `return_line_id` |
| `fact_inventory_snapshot` | `snapshot_date`, `item_id`, `warehouse_id`, `lot_id` |
| `fact_po` | `po_id`, `po_line_id` |
| `fact_receipt` | `receipt_id`, `receipt_line_id` |
| `fact_settlement` | `settlement_id`, `settlement_line_id` |
| `fact_charge_actual` | `charge_id` |
| `fact_exchange_rate` | `rate_date`, `from_currency`, `to_currency` |
| `fact_cost_structure` | `item_id`, `cost_stage`, `period_key`, `warehouse_id` |

### 3. `duplicate_business_keys` (비즈니스 키 중복)

| 속성 | 내용 |
|---|---|
| **심각도** | `HIGH` |
| **적용 대상** | 복합 비즈니스 키가 있는 모든 테이블 |
| **규칙** | 단일 수집 파일 내에서 두 행이 동일한 복합 비즈니스 키를 공유할 수 없음. |
| **트리거** | 중복 제거 윈도우 이후 중복 비즈니스 키 감지. |
| **조치** | 파일 거부. 중복 키 샘플 기록. |
| **비고** | 파일 간 중복은 upsert로 처리 (최신 `_raw_loaded_at` 우선)하지만, 파일 내 중복은 소스 시스템 오류를 나타냄. |

### 4. `type_coercion` (타입 강제 변환)

| 속성 | 내용 |
|---|---|
| **심각도** | `HIGH` |
| **적용 대상** | 모든 테이블 |
| **규칙** | 모든 컬럼 값이 `schema.yaml`에 정의된 선언 타입으로 캐스팅 가능해야 함. |
| **검사 타입** | `VARCHAR`, `INTEGER`, `BIGINT`, `DECIMAL`, `DOUBLE`, `DATE`, `TIMESTAMP`, `BOOLEAN` |
| **트리거** | 값 캐스팅 불가 (예: `"abc"` → `INTEGER`, `"2025-13-01"` → `DATE`). |
| **조치** | 파일 거부. 이슈 로그에 컬럼명, 예상 타입, 실패 값 샘플 기록. |

타입 강제 변환 규칙:

| 대상 타입 | 허용 입력 형식 |
|---|---|
| `DATE` | `YYYY-MM-DD`, `YYYY/MM/DD`, `YYYYMMDD` |
| `TIMESTAMP` | `YYYY-MM-DD HH:MM:SS`, ISO 8601 |
| `DECIMAL` | 숫자 문자열, 선택적 부호, 마침표를 소수점 구분자로 |
| `BOOLEAN` | `true/false`, `1/0`, `yes/no`, `Y/N` (대소문자 무관) |
| `INTEGER/BIGINT` | 숫자 문자열, 소수점 없음 |

### 5. `charge_type_validation` (비용 유형 검증)

| 속성 | 내용 |
|---|---|
| **심각도** | `HIGH` |
| **적용 대상** | `fact_charge_actual`, `fact_settlement` |
| **규칙** | 모든 `charge_type` 값이 `charge_policy.yaml`의 키 또는 `core.dim_charge_policy`에 존재해야 함. |
| **트리거** | 알 수 없는 비용 유형 코드 발견. |
| **조치** | 파일 거부. 알 수 없는 비용 유형 기록. |
| **근거** | 알 수 없는 비용 유형은 배분이 불가능하며 (기준 미정의), 보존을 깨뜨림. |

### 6. `effective_date_join_validation` (유효 일자 조인 검증)

| 속성 | 내용 |
|---|---|
| **심각도** | `HIGH` |
| **적용 대상** | `fact_exchange_rate`, `dim_charge_policy`의 버전 조인 |
| **규칙** | 버전 테이블에 대한 시점 조인은 조회 키당 정확히 0 또는 1개의 매칭 행을 반환해야 함. 2개 이상이면 유효 일자 범위가 겹침. |
| **트리거** | `(key, effective_date)` 조인이 2행 이상 반환. |
| **조치** | 파일 거부. 겹치는 키 범위 기록. |

### 7. `expiry_validation` (유통기한 검증)

| 속성 | 내용 |
|---|---|
| **심각도** | `HIGH` |
| **적용 대상** | `fact_inventory_snapshot`, `fact_receipt` |
| **규칙** | `dim_item`에서 `shelf_life_days IS NOT NULL` (부패성)인 품목은 `expiry_date`가 `NULL`이면 안 됨. |
| **트리거** | 부패성 품목에 유통기한 누락. |
| **조치** | 파일 거부. 유통기한 누락 품목 ID 기록. |

### 8. `referential_integrity` (참조 무결성)

| 속성 | 내용 |
|---|---|
| **심각도** | `MEDIUM` |
| **적용 대상** | 차원 FK가 있는 모든 팩트 테이블 |
| **규칙** | 팩트 테이블의 모든 FK 값에 대응하는 차원 행이 있어야 함. |
| **트리거** | 고아 FK 발견 (예: `fact_order`의 `item_id`가 `dim_item`에 없음). |
| **조치** | 경고 후 파일 적재. 고아 키를 수동 검토용으로 기록. |
| **비고** | 같은 배치의 후속 파일에서 차원이 적재될 수 있으므로 하드 실패 아님. |

### 9. `numeric_range_checks` (숫자 범위 검사)

| 속성 | 내용 |
|---|---|
| **심각도** | `MEDIUM` |
| **적용 대상** | 수량 및 금액 컬럼 |
| **규칙** | 수량은 >= 0이어야 함. 금액은 음수 가능 (크레딧)이지만 동일 비용 유형 중앙값의 10배를 초과하면 플래그. |
| **트리거** | 음수 수량 또는 이상치 금액. |
| **조치** | 경고 후 파일 적재. |

### 10. `date_range_checks` (일자 범위 검사)

| 속성 | 내용 |
|---|---|
| **심각도** | `LOW` |
| **적용 대상** | 모든 일자 컬럼 |
| **규칙** | 일자가 합리적 범위 내여야 함: `2020-01-01` 이전이거나 미래 1년 초과 불가. |
| **트리거** | 유효 범위를 벗어난 일자. |
| **조치** | 정보 수준 로그 후 파일 적재. |

---

## DQ 검사 실행 순서

검사는 위에 나열된 순서대로 실행됩니다. `CRITICAL` 검사가 실패하면 해당 파일의 후속 검사는 건너뜁니다 (빠른 실패). `HIGH` 검사는 모든 `CRITICAL` 검사가 통과된 후에만 실행됩니다.

```
required_columns (CRITICAL)
    |-- 실패 -> 중단
    |-- 통과 ->
null_business_keys (CRITICAL)
    |-- 실패 -> 중단
    |-- 통과 ->
duplicate_business_keys (HIGH)
    |-- 실패 -> 중단
    |-- 통과 ->
type_coercion (HIGH)
    |-- 실패 -> 중단
    |-- 통과 ->
charge_type_validation (HIGH, 조건부)
    |-- 실패 -> 중단
    |-- 통과 ->
effective_date_join_validation (HIGH, 조건부)
    |-- 실패 -> 중단
    |-- 통과 ->
expiry_validation (HIGH, 조건부)
    |-- 실패 -> 중단
    |-- 통과 ->
referential_integrity (MEDIUM) -> 경고, 계속
numeric_range_checks (MEDIUM) -> 경고, 계속
date_range_checks (LOW) -> 정보, 계속
```

---

## 이슈 로그 출력

모든 DQ 결과는 다음 필드와 함께 `ops.ops_issue_log`에 기록됩니다:

- `run_id`: 파이프라인 실행 식별자
- `check_name`: 위의 검사명 중 하나
- `severity`: CRITICAL / HIGH / MEDIUM / LOW
- `table_name`: 대상 CORE 테이블
- `column_name`: 영향받은 컬럼 (테이블 수준 검사 시 NULL)
- `record_count`: 위반 행 수
- `sample_values`: 최대 5개 샘플 값의 JSON 배열
- `message`: 사람이 읽을 수 있는 설명

---

## 사용자 정의 DQ 검사 추가

사용자 정의 검사는 `config/dq_checks.yaml`의 DQ 검사 레지스트리를 확장하여 추가할 수 있습니다:

```yaml
custom_checks:
  - name: "po_amount_cap"
    table: "fact_po"
    severity: "MEDIUM"
    rule: "unit_cost * ordered_qty <= 1000000"
    message: "PO 라인이 100만 상한 초과"
```

사용자 정의 검사는 내장 검사 이후 실행되며 동일한 심각도 에스컬레이션 규칙을 따릅니다.
